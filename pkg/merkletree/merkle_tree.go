package merkletree

import (
	"math"

	"github.com/jiuzhou-zhao/blockchain.go/pkg/chainhash"
)

//
//
//
// MerkleTree represent a Merkle tree.
type MerkleTree struct {
	RootNode *MerkleNode
}

// MerkleNode represent a Merkle tree node.
type MerkleNode struct {
	Left  *MerkleNode
	Right *MerkleNode
	Data  chainhash.Hash
}

// NewMerkleTree creates a new Merkle tree from a sequence of data.
func NewMerkleTree(data []*chainhash.Hash) *MerkleTree {
	if len(data) == 0 {
		panic("no data")
	}

	if len(data)%2 != 0 {
		data = append(data, data[len(data)-1])
	}

	nodes := make([]MerkleNode, 0)
	for _, datum := range data {
		node := NewMerkleNode(nil, nil, datum)
		nodes = append(nodes, *node)
	}

	for i := 0; i < len(data)/2; i++ {
		var newLevel []MerkleNode

		if len(nodes) > 0 && len(nodes)%2 != 0 {
			nodes = append(nodes, nodes[len(nodes)-1])
		}

		for j := 0; j < len(nodes); j += 2 {
			node := NewMerkleNode(&nodes[j], &nodes[j+1], nil)
			newLevel = append(newLevel, *node)
		}

		nodes = newLevel
	}

	if len(nodes) == 1 {
		return &MerkleTree{RootNode: &nodes[0]}
	}

	panic("logic error")
}

// NewMerkleNode creates a new Merkle tree node.
func NewMerkleNode(left, right *MerkleNode, data *chainhash.Hash) *MerkleNode {
	mNode := MerkleNode{}

	if left == nil && right == nil {
		mNode.Data = *data
	} else {
		if left == nil || right == nil {
			panic("left or right node is nil")
		}
		prevHashes := append(left.Data[:], right.Data[:]...)
		mNode.Data = chainhash.DoubleHashH(prevHashes)
	}

	mNode.Left = left
	mNode.Right = right

	return &mNode
}

//
//
//
func nextPowerOfTwo(n int) int {
	// Return the number if it's already a power of 2.
	if n&(n-1) == 0 {
		return n
	}

	// Figure out and return the next power of two.
	exponent := uint(math.Log2(float64(n))) + 1
	return 1 << exponent // 2^exponent
}

func BuildMerkleTreeStore(transactionHashes []*chainhash.Hash) []*chainhash.Hash {
	// Calculate how many entries are required to hold the binary merkle
	// tree as a linear array and create an array of that size.
	nextPoT := nextPowerOfTwo(len(transactionHashes))
	arraySize := nextPoT*2 - 1
	merkles := make([]*chainhash.Hash, arraySize)
	copy(merkles, transactionHashes)

	// Start the array offset after the last transaction and adjusted to the
	// next power of two.
	offset := nextPoT
	for i := 0; i < arraySize-1; i += 2 {
		switch {
		// When there is no left child node, the parent is nil too.
		case merkles[i] == nil:
			merkles[offset] = nil

		// When there is no right child, the parent is generated by
		// hashing the concatenation of the left child with itself.
		case merkles[i+1] == nil:
			newHash := HashMerkleBranches(merkles[i], merkles[i])
			merkles[offset] = newHash

		// The normal case sets the parent node to the double sha256
		// of the concatenation of the left and right children.
		default:
			newHash := HashMerkleBranches(merkles[i], merkles[i+1])
			merkles[offset] = newHash
		}
		offset++
	}

	return merkles
}

func HashMerkleBranches(left, right *chainhash.Hash) *chainhash.Hash {
	// Concatenate the left and right nodes.
	var hash [chainhash.HashSize * 2]byte
	copy(hash[:chainhash.HashSize], left[:])
	copy(hash[chainhash.HashSize:], right[:])

	newHash := chainhash.DoubleHashH(hash[:])
	return &newHash
}

func CalcMerkleTreeRootHash(transactionHashes []*chainhash.Hash) *chainhash.Hash {
	// hs := BuildMerkleTreeStore(transactionHashes)
	// return hs[len(hs)-1]
	return &NewMerkleTree(transactionHashes).RootNode.Data
}
